# IPA Project Overview & Component Breakdown

## Purpose

This document provides a high-level breakdown of the IPA project into independently developable components, with clear API boundaries and dependencies.

## Key Architectural Concepts

### Task & Pod (1:1 Relationship)
Each **task** creates exactly one **primary pod**. The pod is an isolated Elixir supervisor tree that contains all components needed to manage the task lifecycle. While future versions may support child pods, the current design limits nesting to maintain system clarity and prevent excessive complexity.

### Workstreams (Parallel Work Layer)
Once a pod starts and generates the initial spec, the **Pod Scheduler** breaks the task into multiple **workstreams** that can be worked on in parallel. Key characteristics:

- **One agent per workstream**: Each workstream is assigned to a single agent
- **Dynamic creation**: Workstreams can be created as work progresses, not just at the start
- **Dependency management**: Workstreams can depend on each other (explicitly documented in specs)
- **Concurrency control**: Pod-level max concurrency limits prevent resource exhaustion
- **Event-sourced**: All workstream state is tracked via events in the task's event stream
- **Contextual CLAUDE.md**: Each workstream gets its own generated CLAUDE.md with specific context

Workstreams are the primary mechanism for parallel work execution within a pod.

### Communications (Coordination Layer)
A structured communication system enables **human-agent** and **agent-agent** coordination:

- **Pod-scoped**: All messages are visible within the pod
- **Threaded conversations**: Like Slack, messages can be organized in threads
- **Typed messages**: Question, approval, update, blocker message types
- **Human authority**: Humans have ultimate decision-making power
- **Real-time**: Leverages events and LiveView for instant visibility
- **Inbox/notifications**: Agents and humans get notified of messages needing attention

Communications are first-class citizens in the data model, stored as events and projected into state.

### CLAUDE.md Template System
Multi-level contextual instructions ensure agents have appropriate context:

- **System-level**: Static file with overall IPA architecture and conventions
- **Pod-level**: Static template with task-specific context injected
- **Workstream-level**: Generated by Pod Scheduler with workstream-specific context

Each workspace gets the appropriate CLAUDE.md file injected at creation time.

## Architecture Layers

### Layer 1: Shared Persistence (Foundation)
Components that provide shared state management across all pods.

- **1.1 SQLite Event Store**
  - SQLite database setup
  - Event store implementation (append, load, replay)
  - JSON event serialization
  - Single stream per task (workstream events stored in task stream)
  - Snapshot support for performance
  - Schema: streams, events, snapshots tables

### Layer 2: Pod Infrastructure (Per-Task)
Components that run within each task pod.

- **2.1 Task Pod Supervisor**
  - DynamicSupervisor for pod lifecycle
  - Child process spawning and supervision
  - Pod registry

- **2.2 Pod State Manager**
  - Event loading from persisted store
  - In-memory state projections (task, workstreams, messages)
  - Pod-local pub-sub
  - Event append with optimistic concurrency
  - Workstream state tracking

- **2.3 Pod Scheduler**
  - State machine logic (phase transitions)
  - Workstream planning and creation (dynamic)
  - Agent orchestration (multi-agent, multi-workstream)
  - Workstream dependency management
  - Concurrency control (max concurrent workstreams)
  - Action dispatcher
  - Cooldown management

- **2.4 Pod Workspace Manager**
  - Workspace creation/cleanup per workstream
  - Git operations
  - File operations (inspection utilities)
  - CLAUDE.md injection
  - Workspace registry

- **2.5 Pod External Sync Engine**
  - GitHub connector
  - JIRA connector
  - Sync queue with deduplication
  - External change detection
  - Workstream progress reporting

- **2.6 Pod LiveView UI**
  - Real-time task detail view
  - **Workstreams Tab**: Grid of active workstreams, progress, dependencies
  - **Communications Tab**: Threaded messages, inbox, approvals
  - Agent monitoring per workstream
  - Approval interactions
  - Workspace browser

- **2.7 Pod Communications Manager (NEW)**
  - Threaded message posting
  - Message type handling (question, approval, update, blocker)
  - Inbox/notification management
  - Human approval workflows
  - Real-time message pub-sub

- **2.8 CLAUDE.md Template System (NEW)**
  - System-level template (static)
  - Pod-level template generator
  - Workstream-level template generator
  - Context injection logic

### Layer 3: Central Management (Singleton)
Components that manage the overall system.

- **3.1 Central Task Manager**
  - Pod lifecycle management (start/stop)
  - Pod registry
  - Task listing

- **3.2 Central Dashboard UI**
  - Task list view with workstream counts
  - Unread message indicators
  - Task creation
  - Navigation to pod UIs

## Component Summary

| ID | Component | Layer | Dependencies | Estimated Effort |
|----|-----------|-------|--------------|------------------|
| 1.1 | SQLite Event Store | 1 | None | 1 week (includes workstream events) |
| 2.1 | Task Pod Supervisor | 2 | 1.1 | 2 days |
| 2.2 | Pod State Manager | 2 | 1.1, 2.1 | 1.5 weeks (includes workstream/message projections) |
| 2.3 | Pod Scheduler | 2 | 1.1, 2.1, 2.2, 2.4, 2.7, 2.8 | 3 weeks (orchestration engine) |
| 2.4 | Pod Workspace Manager | 2 | 2.1 | 3-4 days (includes CLAUDE.md injection) |
| 2.5 | Pod External Sync | 2 | 1.1, 2.1, 2.2 | 1.5 weeks (includes workstream reporting) |
| 2.6 | Pod LiveView UI | 2 | 1.1, 2.1, 2.2, 2.7 | 2 weeks (includes workstreams + comms tabs) |
| 2.7 | Pod Communications Manager | 2 | 1.1, 2.1, 2.2 | 2.5 weeks (new complex component) |
| 2.8 | CLAUDE.md Templates | 2 | 2.2 | 1 week (template system) |
| 3.1 | Central Task Manager | 3 | 1.1, 2.1 | 2-3 days |
| 3.2 | Central Dashboard UI | 3 | 3.1 | 2-3 days (includes message counts) |

**Total Estimated Timeline: ~15 weeks** (full build with all new concepts)

## Development Streams

Based on dependencies, we can parallelize work into these streams:

### Stream A: Foundation → Pod Core → Central Management
1. SQLite Event Store (1.1) - **Required first** (~1 week)
2. Task Pod Supervisor (2.1) (~2 days)
3. Pod State Manager (2.2) (~1.5 weeks)
4. Central Task Manager (3.1) (~2-3 days)
5. Central Dashboard UI (3.2) (~2-3 days)

### Stream B: Pod Workspace + Templates (parallel with A after 2.1)
1. Pod Workspace Manager (2.4) (~3-4 days)
2. CLAUDE.md Templates (2.8) (~1 week)

### Stream C: Pod Communications (after 2.2)
1. Pod Communications Manager (2.7) (~2.5 weeks)

### Stream D: Pod Scheduler (after 2.2 + 2.4 + 2.7 + 2.8)
1. Pod Scheduler (2.3) (~3 weeks) - **Most complex component**

### Stream E: Pod UI (parallel with D after 2.2 + 2.7)
1. Pod LiveView UI (2.6) (~2 weeks)

### Stream F: External Sync (parallel after 2.2)
1. Pod External Sync Engine (2.5) (~1.5 weeks)

## Critical API Boundaries

### Between Layer 1 and Layer 2

**Event Store API** (consumed by Pod State Manager):
```elixir
# Append event to SQLite (single task stream)
{:ok, version} = Ipa.EventStore.append(
  task_id,  # stream_id
  :workstream_created,
  %{workstream_id: "ws-1", spec: "...", dependencies: ["ws-2"]},
  actor_id: "scheduler"
)

# Load all events for a task (includes workstream events)
{:ok, events} = Ipa.EventStore.load_events(task_id)
# Returns: [%{event_type: :task_created, data: %{...}, version: 1},
#           %{event_type: :workstream_created, data: %{...}, version: 2}, ...]

# Load events since version
{:ok, events} = Ipa.EventStore.load_events_since(task_id, version)

# Save snapshot for performance
:ok = Ipa.EventStore.save_snapshot(task_id, state, version)

# Load snapshot
{:ok, snapshot} = Ipa.EventStore.load_snapshot(task_id)
# Returns: %{state: %{...}, version: 42}
```

### Within Pod (Layer 2 Internal)

**Pod State Manager API** (consumed by Scheduler, ExternalSync, LiveView, CommunicationsManager):
```elixir
# Start state manager
{:ok, pid} = Ipa.Pod.State.start_link(task_id)

# Append event (calls EventStore underneath)
{:ok, new_version} = Ipa.Pod.State.append_event(
  task_id,
  :workstream_created,
  %{workstream_id: "ws-1", spec: "...", agent_id: nil},
  expected_version
)

# Get current state (includes workstreams, messages)
{:ok, state} = Ipa.Pod.State.get_state(task_id)
# Returns: %{
#   phase: :executing,
#   workstreams: %{"ws-1" => %{...}},
#   messages: [...],
#   inbox: [...],
#   version: 5,
#   ...
# }

# Get workstream state
{:ok, workstream} = Ipa.Pod.State.get_workstream(task_id, workstream_id)

# Get messages
{:ok, messages} = Ipa.Pod.State.get_messages(task_id, thread_id \\ nil)

# Get inbox
{:ok, inbox} = Ipa.Pod.State.get_inbox(task_id)

# Subscribe to changes (pub-sub)
Phoenix.PubSub.subscribe(Ipa.PubSub, "pod:#{task_id}:state")
# Receives: {:state_updated, new_state}
```

**Pod Scheduler API** (consumed by Pod State Manager for callbacks):
```elixir
# Start scheduler (subscribes to state changes internally)
{:ok, pid} = Ipa.Pod.Scheduler.start_link(task_id)

# Create workstream (called internally or via LiveView)
:ok = Ipa.Pod.Scheduler.create_workstream(task_id, spec, dependencies)

# Interrupt agent (called by LiveView)
:ok = Ipa.Pod.Scheduler.interrupt_agent(task_id, agent_id)
```

**Pod Workspace Manager API** (consumed by Scheduler):
```elixir
# Create workspace for agent (with CLAUDE.md injection)
{:ok, workspace_path} = Ipa.Pod.WorkspaceManager.create_workspace(
  task_id,
  workstream_id,
  agent_id,
  %{
    repo: "git@github.com:xorvo/ipa.git",
    branch: "main",
    claude_md: generated_claude_md_content
  }
)

# Cleanup workspace
:ok = Ipa.Pod.WorkspaceManager.cleanup_workspace(task_id, workstream_id)

# Read file (inspection utility)
{:ok, contents} = Ipa.Pod.WorkspaceManager.read_file(
  task_id,
  workstream_id,
  "lib/some_file.ex"
)

# List files (for file browser)
{:ok, files} = Ipa.Pod.WorkspaceManager.list_files(task_id, workstream_id)
```

**Pod Communications Manager API** (consumed by Scheduler, Agents, LiveView):
```elixir
# Post message
{:ok, message_id} = Ipa.Pod.CommunicationsManager.post_message(
  task_id,
  type: :question,
  content: "Should we proceed with approach A or B?",
  author: "agent-123",
  thread_id: nil  # or parent message ID
)

# Request approval (blocking message type)
{:ok, message_id} = Ipa.Pod.CommunicationsManager.request_approval(
  task_id,
  workstream_id: "ws-1",
  question: "Ready to merge PR?",
  options: ["Yes", "No, needs changes"]
)

# Mark message read
:ok = Ipa.Pod.CommunicationsManager.mark_read(task_id, message_id)

# Get inbox
{:ok, inbox} = Ipa.Pod.CommunicationsManager.get_inbox(task_id, unread_only?: true)

# Get thread
{:ok, messages} = Ipa.Pod.CommunicationsManager.get_thread(task_id, thread_id)
```

**CLAUDE.md Template System API** (consumed by Scheduler, WorkspaceManager):
```elixir
# Generate pod-level CLAUDE.md
{:ok, content} = Ipa.Pod.ClaudeMdTemplates.generate_pod_level(
  task_id,
  task_title: "Implement user authentication",
  task_spec: "..."
)

# Generate workstream-level CLAUDE.md
{:ok, content} = Ipa.Pod.ClaudeMdTemplates.generate_workstream_level(
  task_id,
  workstream_id,
  workstream_spec: "...",
  dependencies: ["ws-2"],
  related_workstreams: [...]
)

# Get system-level CLAUDE.md
{:ok, content} = Ipa.Pod.ClaudeMdTemplates.get_system_level()
```

**Pod External Sync API** (consumed by Pod State Manager callbacks):
```elixir
# Start external sync (subscribes to state changes internally)
{:ok, pid} = Ipa.Pod.ExternalSync.start_link(task_id)

# Force sync now (called by LiveView)
:ok = Ipa.Pod.ExternalSync.sync_now(task_id)

# Report workstream progress to external systems
:ok = Ipa.Pod.ExternalSync.sync_workstream_status(task_id, workstream_id)
```

### Between Layer 3 and Layer 2

**Central Task Manager API** (consumed by Central Dashboard):
```elixir
# Start a pod for a task
{:ok, pod_pid} = Ipa.CentralManager.start_pod(task_id)

# Stop a pod
:ok = Ipa.CentralManager.stop_pod(task_id)

# List active pods
[task_id1, task_id2] = Ipa.CentralManager.get_active_pods()

# Check if pod is running
true = Ipa.CentralManager.pod_running?(task_id)
```

## Event Schema

### Core Events (stored in task event stream)

```elixir
# Task lifecycle
:task_created              # %{title: string, created_by: user_id}
:task_completed            # %{completed_at: timestamp}
:task_cancelled            # %{reason: string}

# Phase transitions
:transition_requested      # %{from_phase: atom, to_phase: atom, reason: string}
:transition_approved       # %{to_phase: atom, approved_by: user_id}
:transition_rejected       # %{reason: string}

# Spec phase
:spec_updated              # %{spec: map}
:spec_approved             # %{approved_by: user_id}

# Planning phase (now creates workstreams)
:plan_generated            # %{plan: map, generated_by: agent_id}
:plan_approved             # %{approved_by: user_id}

# Workstream lifecycle (NEW)
:workstream_created        # %{workstream_id: uuid, spec: string, dependencies: [ws_id]}
:workstream_spec_generated # %{workstream_id: uuid, spec: map}
:workstream_agent_started  # %{workstream_id: uuid, agent_id: uuid, workspace: string}
:workstream_completed      # %{workstream_id: uuid, result: map, duration_ms: integer}
:workstream_failed         # %{workstream_id: uuid, error: string}
:workstream_blocked        # %{workstream_id: uuid, blocking_dependency: ws_id}

# Development phase
:agent_started             # %{agent_id: uuid, workstream_id: uuid, agent_type: string, workspace: string}
:agent_completed           # %{agent_id: uuid, workstream_id: uuid, result: map}
:agent_failed              # %{agent_id: uuid, workstream_id: uuid, error: string}
:agent_interrupted         # %{agent_id: uuid, interrupted_by: user_id}

# Communications (NEW)
:message_posted            # %{message_id: uuid, type: atom, content: string, author: string, thread_id: uuid | nil}
:reply_posted              # %{message_id: uuid, thread_id: uuid, content: string, author: string}
:approval_requested        # %{message_id: uuid, workstream_id: uuid, question: string, options: [string]}
:approval_given            # %{message_id: uuid, approved_by: user_id, choice: string}
:notification_created      # %{notification_id: uuid, recipient: string, message_id: uuid, type: atom}
:notification_read         # %{notification_id: uuid, read_by: user_id}

# External sync
:github_pr_created         # %{pr_number: integer, pr_url: string, workstream_id: uuid | nil}
:github_pr_updated         # %{pr_number: integer, workstream_id: uuid | nil}
:jira_ticket_updated       # %{ticket_id: string, status: string, workstream_id: uuid | nil}
```

### State Projection Schema

The in-memory state maintained by Pod State Manager:

```elixir
%{
  # Metadata
  task_id: uuid,
  version: integer,           # Event version for optimistic concurrency
  created_at: timestamp,
  updated_at: timestamp,

  # Core state
  phase: :spec_clarification | :workstream_planning | :executing | :integration | :review | :completed | :cancelled,
  title: string,

  # Phase-specific data
  spec: %{
    description: string,
    requirements: [string],
    approved?: boolean,
    approved_by: user_id | nil
  },

  plan: %{
    steps: [%{description: string, status: atom}],
    approved?: boolean,
    approved_by: user_id | nil
  },

  # Workstreams (NEW)
  workstreams: %{
    "ws-1" => %{
      workstream_id: "ws-1",
      spec: string,
      status: :pending | :in_progress | :blocked | :completed | :failed,
      agent_id: uuid | nil,
      dependencies: [workstream_id],
      blocking_on: [workstream_id],  # Which dependencies are not yet complete
      workspace: string | nil,
      started_at: timestamp | nil,
      completed_at: timestamp | nil,
      result: map | nil,
      error: string | nil
    }
  },

  # Concurrency control
  max_workstream_concurrency: integer,  # Default: 3
  active_workstream_count: integer,

  # Active agents (per workstream)
  agents: [
    %{
      agent_id: uuid,
      workstream_id: uuid,
      agent_type: string,
      status: :running | :completed | :failed | :interrupted,
      workspace: string,
      started_at: timestamp,
      completed_at: timestamp | nil
    }
  ],

  # Communications (NEW)
  messages: [
    %{
      message_id: uuid,
      type: :question | :approval | :update | :blocker,
      content: string,
      author: string,  # "agent-123" or "user-456"
      thread_id: uuid | nil,  # Parent message ID for threading
      workstream_id: uuid | nil,  # Associated workstream
      posted_at: timestamp,
      read_by: [user_id]
    }
  ],

  inbox: [
    %{
      notification_id: uuid,
      recipient: string,
      message_id: uuid,
      type: :needs_approval | :question_asked | :workstream_completed,
      read?: boolean,
      created_at: timestamp
    }
  ],

  # External sync status
  external_sync: %{
    github: %{pr_number: integer | nil, pr_url: string | nil, synced_at: timestamp | nil},
    jira: %{ticket_id: string | nil, status: string | nil, synced_at: timestamp | nil}
  }
}
```

## Critical Design Considerations

### Single Event Stream per Task
All events (task, workstreams, agents, messages) are stored in a single event stream per task. This design choice:

- **Simplifies version management**: Single version number for entire task
- **Atomic operations**: All state changes are serialized
- **Easier replay**: Single stream to replay for state reconstruction
- **Conflict handling**: Optimistic concurrency with version checking prevents conflicts
- **Safeguards**: Retry logic on version conflicts ensures consistency

While concurrent workstream writes may encounter version conflicts, the retry mechanism ensures all events are eventually appended successfully.

### Optimistic Concurrency
Use version checking when appending events to detect conflicts:
```elixir
Ipa.Pod.State.append_event(task_id, event_type, data, expected_version)
# Returns {:ok, new_version} | {:error, :version_conflict}
```

Components must retry on version conflict with fresh state.

### Pod-Local Pub-Sub
Components within a pod communicate via pub-sub topic `pod:{task_id}:state`:
- Scheduler subscribes to react to state changes (workstream completion, approvals)
- CommunicationsManager subscribes to send notifications
- ExternalSync subscribes to push updates
- LiveView subscribes for real-time UI updates

### State Persistence
Pods must flush state to disk before shutdown. On restart, state is reloaded from persisted event store by replaying all events.

### Workstream Dependencies
Dependencies between workstreams are explicitly tracked:
- `dependencies`: List of workstream IDs that must complete first
- `blocking_on`: Subset of dependencies that are not yet complete
- Scheduler monitors completions and unblocks waiting workstreams

### Multi-Agent Coordination via Communications
Agents communicate through the Communications Manager:
- Questions posted as messages visible to all agents and human
- Approval requests block workstream progress until answered
- Updates keep everyone informed of progress
- Blockers signal critical issues needing attention

## Testing Strategy

### Unit Tests (per component)
- Event handling logic
- State projection correctness (including workstreams, messages)
- API contract validation
- Workstream dependency resolution

### Integration Tests (cross-component)
- Pod lifecycle (start → run → stop)
- Event append → pub-sub → state update flow
- Multi-workstream execution with dependencies
- Agent spawn → workspace creation → execution
- Message posting → inbox notification flow
- External sync trigger → connector call

### End-to-End Tests
- Full task workflow: create → spec → workstream planning → parallel execution → integration → complete
- Pod restart with state recovery (including workstreams and messages)
- Multi-pod isolation
- Concurrent workstream execution with max concurrency limits
- Human approval workflow (spec, plan, transitions, workstream decisions)

## Next Steps

1. **Review this overview** - Ensure component boundaries and APIs make sense
2. **Update CLAUDE.md** - Add new concepts to root CLAUDE.md
3. **Create component specs** - Detailed spec for new/updated components:
   - 2.3 Pod Scheduler (MAJOR updates - orchestration engine)
   - 2.7 Pod Communications Manager (NEW)
   - 2.8 CLAUDE.md Templates (NEW)
   - Updates to existing specs (2.2, 2.4, 2.5, 2.6, 3.2)
4. **Update dependency graph** - Add new components and dependencies
5. **Update STATUS.md** - Track spec refactor progress
6. **Initialize project** - Phoenix app, SQLite setup, database
7. **Begin Stream A (Foundation)** - Start with component 1.1
