# IPA System Context

This file provides context about the IPA (Intelligent Process Automation) system architecture and conventions.

## Architecture

IPA uses a pod-based architecture where each task runs in an isolated Elixir supervisor tree. The system follows event sourcing principles with all state changes recorded as immutable events in SQLite.

### Core Components

- **Event Store**: SQLite-based event sourcing foundation
- **Pod State Manager**: Event-sourced state projections
- **Pod Scheduler**: Multi-agent orchestration engine
- **Workspace Manager**: Isolated agent workspaces
- **Communications Manager**: Human-agent and agent-agent messaging
- **External Sync**: GitHub/JIRA integration

## Workstreams

Tasks are broken down into multiple **workstreams** that can be worked on in parallel:

- **One agent per workstream**: Each workstream is assigned to a single agent
- **Dynamic creation**: Workstreams can be created as work progresses
- **Dependency management**: Workstreams can depend on each other
- **Concurrency control**: Pod-level max concurrency limits prevent resource exhaustion
- **Event-sourced**: All workstream state is tracked via events

## Communications

Agents and humans coordinate via a structured messaging system:

- **Pod-scoped**: All messages are visible within the pod
- **Threaded conversations**: Like Slack, messages can be organized in threads
- **Typed messages**: Question, approval, update, blocker message types
- **Human authority**: Humans have ultimate decision-making power
- **Real-time**: Leverages events and LiveView for instant visibility

## Development Workflow

1. **Spec**: Write detailed specification in `specs/` folder
2. **Review**: Get spec reviewed and approved
3. **Code**: Implement the component
4. **Test**: Test locally with `mix test`
5. **Review**: Code review
6. **PR**: Create pull request with `gh pr create`
7. **Merge**: After approval

## Common Commands

```bash
# Install dependencies
mix deps.get

# Run all tests
mix test

# Run specific test file
mix test test/path/to/test_file.exs

# Run specific test by line number
mix test test/path/to/test_file.exs:42

# Format code
mix format

# Start Phoenix server
mix phx.server

# Interactive Elixir shell
iex -S mix phx.server

# Query SQLite database
sqlite3 priv/ipa.db

# Create git commit
git add . && git commit -m "message"

# Create pull request
gh pr create --title "title" --body "body"
```

## File Organization

- `lib/` - Application source code
- `test/` - Test files
- `specs/` - Component specifications
  - `specs/{component}/spec.md` - Detailed specification
  - `specs/{component}/tracker.md` - Component-specific todos and logs
  - `specs/{component}/review.md` - Review findings
- `STATUS.md` - Project status tracker
- `CLAUDE.md` - Project-level instructions (you are reading context from templates)

## Event Sourcing

All state changes are immutable events stored in SQLite:
- Single event stream per task
- Events include: task lifecycle, workstreams, agents, messages
- State is reconstructed by replaying events
- Optimistic concurrency control prevents conflicts
- Snapshots optimize performance

## Testing

- Use `ExUnit` for all tests
- Tests use `Ipa.DataCase` for database access
- Ecto Sandbox isolates test transactions
- Async tests are supported: `use Ipa.DataCase, async: true`

## Code Style

- Follow Elixir conventions
- Use `mix format` before committing
- Write clear, descriptive function names
- Add `@doc` documentation for public functions
- Keep functions focused and small
